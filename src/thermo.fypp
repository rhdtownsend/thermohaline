#:include 'forum.inc'

! preprocessor macros

! defines the prob size
#:def prob_size(N)
4*(2*${N}$+1)
#:enddef

! defines the size of parity blocks
#:def block_size(N)
2*(2*${N}$+1)
#:enddef

program thermo

   ! Uses

   use forum_m, split_ => split
   use params_m
   use matrix_m
   use finger_m
   use LU_solver_m
   use eig_solver_m

   use f95_lapack

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Variables

   character(:), allocatable :: nml_file

   ! Namelist parameters
   integer                  :: unit
   real(RD)                 :: k_z_min
   real(RD)                 :: k_z_max
   integer                  :: n_k_z
   logical                  :: log_k_z
   logical                  :: rescale_k_z_min
   logical                  :: rescale_k_z_max
   real(RD)                 :: R0
   real(RD)                 :: Pr
   real(RD)                 :: tau
   real(RD)                 :: H_B
   real(RD)                 :: D_B
   real(RD)                 :: w_f
   integer                  :: N
   logical                  :: split
   integer                  :: NEV
   character(256)           :: out_file

   ! other variables
   real(RD)                 :: lam_f
   real(RD)                 :: l_f
   real(RD), allocatable    :: k_z(:)
   type(params_t)           :: pa
   integer                  :: i
   complex(RD), allocatable :: sig(:,:)
   complex(RD), allocatable :: sig_max_ar(:), sig_max_la(:)
   type(hdf5io_t)           :: hi

   ! some of my additions
   integer                  :: info
   logical, allocatable     :: ar_sucess(:)
   ! real(RD), allocatable    :: resid(:)
   integer, parameter       :: ar_start = 1
   real(RD), allocatable        :: time(:,:)

   namelist /params/ &
      k_z_min, k_z_max, n_k_z, log_k_z, rescale_k_z_min, rescale_k_z_max, &
      R0, Pr, tau, H_B, D_B, w_f, &
      N, split, NEV, &
      out_file

   ! Read arguments

   @:ASSERT(n_arg() == 1,'Syntax: thermo nml_file')

   call get_arg(1, nml_file)

   ! Read namelist parameters

   k_z_min = 1e-1
   k_z_max = 1.
   log_k_z = .FALSE.
   rescale_k_z_min = .FALSE.
   rescale_k_z_max = .FALSE.

   R0 = 1.
   Pr = 1.
   tau = 1.
   Pr = 1.
   
   H_B = 1.
   D_B = 1.
   w_f = 1.

   split = .FALSE.

   open(NEWUNIT=unit, STATUS='OLD', FILE=nml_file)
   read(unit, NML=params)
   close(unit)

   print *,'R0  :', R0
   print *,'Pr  :', Pr
   print *,'tau :', tau
   print *,'H_B :', H_B
   print *,'D_B :', D_B
   print *,'w_f :', w_f

   ! If necessary, rescale k_z range

   call solve_finger(R0, Pr, tau, lam_f, l_f)

   print *, 'lam_f :', lam_f
   print *, 'l_f^2 :', l_f**2

   if (rescale_k_z_min) k_z_min = k_z_min*l_f
   if (rescale_k_z_max) k_z_max = k_z_max*l_f

   print *, 'k_z_min :', k_z_min
   print *, 'k_z_max :', k_z_max

   print *, 'deg k_z :', 2._RD * SQRT(H_B) / ABS(D_B - Pr)
      
   ! Loop over k_z

   allocate(k_z(n_k_z))

   allocate(sig(@{prob_size(N)}@, n_k_z))
   allocate(sig_max_ar(n_k_z))
   allocate(sig_max_la(n_k_z))
   allocate(ar_sucess(n_k_z))
   allocate(time(4, n_k_z))
   ! allocate(resid(@{prob_size(N)}@))

   ar_sucess = .true.

   !!$OMP PARALLEL DO PRIVATE(pa)
   do i = 1, n_k_z

      ! print *, 'i = ', i

      ! Set up parameters
 
      if (log_k_z) then
         k_z(i) = 10**((LOG10(k_z_min)*(n_k_z-i) + LOG10(k_z_max)*(i-1))/(n_k_z - 1))
      else
         k_z(i) = (k_z_min*(n_k_z-i) + k_z_max*(i-1))/(n_k_z - 1)
      endif

      pa = params_t(R0, Pr, tau, H_B, D_B, w_f, k_z(i))

      ! print the matrix
      block
         real(RD) :: A(@{prob_size(N)}@, @{prob_size(N)}@)
         real(RD) :: A_split(@{block_size(N)}@, @{block_size(N)}@)
         character(len=100) :: file_name

         write(file_name, '(a,i0.4,a)') 'matrices/mat_', i, '.txt'

         call eval_matrix(N, pa, A)
         call write_matrix(A, TRIM(file_name))

         write(file_name, '(a,i0.4,a)') 'matrices/mat_p_parity_', i, '.txt'

         call eval_matrix(N, pa, A_split, .true.)
         call write_matrix(A_split, TRIM(file_name))

         write(file_name, '(a,i0.4,a)') 'matrices/mat_m_parity_', i, '.txt'

         call eval_matrix(N, pa, A_split, .false.)
         call write_matrix(A_split, TRIM(file_name))

      end block

      ! Evaluate the full set of eigenvalues
      call CPU_TIME(time(1,i))
      call eigen_all(N, pa, split, sig(:,i))
      call CPU_TIME(time(2,i))

      sig_max_la(i) = max_real(sig(:,i))

      ! Evaluate the eigenvalue with largest real part

      if (i > ar_start) then

         call CPU_TIME(time(3,i))
         call apply_arpack(N, pa, sig_max_ar(i-ar_start), split, sig_max_ar(i), info, NEV)
         call CPU_TIME(time(4,i))
         ! call eigen_max(N, pa, sig_max_ar(i))

         if (info /= 0) then
            ! ARPACK failed, use the LAPACK result
            sig_max_ar(i) = sig_max_la(i)
            ar_sucess(i)  = .false.
            ! print *, 'ARPACK failed at index i = ', i
            ! stop
         else
            ! print *, achar(9), 'LAPACK result = ', sig_max_la(i)%re, sig_max_la(i)%im, &
            !    'ARPACK result = ', sig_max_ar(i)%re, sig_max_ar(i)%im
         end if
         ! if (i == 1458) stop
         ! stop
      else

         ! call RANDOM_NUMBER(resid)
         sig_max_ar(i) = sig_max_la(i)
         time(3:4, i) = 0
         ! print *, 'i = ', i, 'LAPACK result = ', sig_max_la(i)

      end if
      ! print *, ''
      ! print *, 'i = ', i, 'ARPACK result = ', sig_max(i)
      ! if (i == 1294) stop


   end do

   print *,'loop complete!'

   ! Write out results

   hi = hdf5io_t(out_file, CREATE_FILE)

   call hi%write_attr('lam_f', lam_f)
   call hi%write_attr('l_f', l_f)

   call hi%write_dset('k_z', k_z)
   call hi%write_dset('sig', sig)
   call hi%write_dset('sig_max_la', sig_max_la)
   call hi%write_dset('sig_max_ar', sig_max_ar)
   call hi%write_dset('ar_sucess', ar_sucess)
   call hi%write_dset('la_time', time(2,:) - time(1,:))
   call hi%write_dset('ar_time', time(4,:) - time(3,:))

   call hi%final()

   ! Finished

contains

   subroutine eigen_all(N, pa, split, sig)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      logical, intent(in)        :: split
      complex(RD), intent(out)   :: sig(:)

      real(RD), allocatable :: A(:,:)
      real(RD), allocatable :: wr(:)
      real(RD), allocatable :: wi(:)

      if (split) then

         allocate(A(@{block_size(N)}@,@{block_size(N)}@))
         allocate(wr(@{block_size(N)}@))
         allocate(wi(@{block_size(N)}@))

         call eval_matrix(N, pa, A, .TRUE.)
         call LA_GEEV(A, wr, wi)
         sig(1::2) = CMPLX(wr, wi, KIND=RD)
         
         call eval_matrix(N, pa, A, .FALSE.)
         call LA_GEEV(A, wr, wi)
         sig(2::2) = CMPLX(wr, wi, KIND=RD)

      else

         allocate(A(@{prob_size(N)}@,@{prob_size(N)}@))
         allocate(wr(@{prob_size(N)}@))
         allocate(wi(@{prob_size(N)}@))

         call eval_matrix(N, pa, A)
         call LA_GEEV(A, wr, wi)
         sig = CMPLX(wr, wi, KIND=RD)
         
      end if

   end subroutine eigen_all

   ! !****

   subroutine eigen_max(N, pa, sig_max)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      complex(RD), intent(out)   :: sig_max

      integer, parameter   :: NEV = 25
      integer, parameter   :: NCV = 2*NEV + 1
      integer, parameter   :: LWORKL = 3*NCV**2 + 6*NCV
      real(RD), parameter  :: TOL = 1E-6_RD
      character(len=2), parameter :: which = 'LR'
      character, parameter :: bmat = 'I'

      integer  :: ido
      integer  :: iparam(11)
      integer  :: ipntr(14)
      real(RD) :: resid(@{prob_size(N)}@)
      real(RD) :: v(@{prob_size(N)}@,NCV)
      real(RD) :: workd(3*@{prob_size(N)}@)
      real(RD) :: workl(LWORKL)
      integer  :: info
      real(RD) :: dr(NEV+1)
      real(RD) :: di(NEV+1)
      real(RD) :: z(@{prob_size(N)}@,NEV+1)
      real(RD) :: workev(3*NCV)
      logical  :: select(NCV)
      integer  :: ierr

      real(RD) :: A(@{prob_size(N)}@,@{prob_size(N)}@)

      call eval_matrix(N, pa, A)

      ! Find the maximal eigenvalue

      ! First set up parameters

      iparam = 0

      iparam(1) = 1
      iparam(3) = 300
      iparam(7) = 1

      ido  = 0
      info = 0

      iter_loop : do

         call DNAUPD(ido, bmat, @{prob_size(N)}@, which, NEV, TOL, resid, &
            NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
            info)

         if (ido == -1 .OR. ido == 1) then

            associate( &
               x => workd(ipntr(1):ipntr(1)+@{prob_size(N)}@-1), &
               y => workd(ipntr(2):ipntr(2)+@{prob_size(N)}@-1))

               ! call eval_prod_full(N, pa, x, y)
               y = MATMUL(A, x)

            end associate

         else

            exit iter_loop

         end if

      end do iter_loop

      ! Check for convergence

      if (info /= 0) then

         print *, ' '
         print *, ' Error with _naupd, info = ', info
         print *, ' Check the documentation of _naupd'
         print *, ' '
         stop
         ! return

      ! else if (iparam(5) /= NEV) then
      !    print *, 'NCONV does not match NEV. NCONV = ', iparam(5)
         ! call write_matrix(A, 'failed_mtx_no_shift.txt')
         ! stop

      else

         if (iparam(5) /= NEV) print *, 'NCONV does not match NEV. NCONV = ', iparam(5)
         call DNEUPD(.FALSE., 'A', select, dr, di, z, SIZE(z, 1), &
            0._RD, 0._RD, workev, bmat, @{prob_size(N)}@, which, NEV, TOL, &
            resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
            LWORKL, ierr)

         if (ierr /= 0) then

            print *, ' '
            print *, ' Error with _neupd, info = ', ierr
            print *, ' Check the documentation of _neupd. '
            print *, ' '
            stop
            ! return

         end if
         
      endif

      ! Store the eigenvalue

      sig_max = CMPLX(dr(NEV), di(NEV), KIND=RD)

      ! print *,sig_max

   end subroutine eigen_max

   subroutine apply_shift(sig_shift, A)
      real(RD), intent(in)    :: sig_shift
      real(RD), intent(inout) :: A(:,:)

      integer :: i

      @:ASSERT_DEBUG(SIZE(A,1) == SIZE(A,2),'non-square matrix given to shift')

      do i = 1, SIZE(A, 1)
         A(i,i) = A(i,i) - sig_shift
      end do

   end subroutine apply_shift

   subroutine write_matrix(A, fname)
      ! writes matrix to file in row major order
      real(RD), intent(in) :: A(:,:)
      character(*), intent(in) :: fname
      integer :: io, i

      open(newunit=io, file=fname, status='replace', action='write')
      do i = 1, SIZE(A, 1)
         write(io, *) A(i, :)
      end do
      close(io)

   end subroutine write_matrix

   subroutine apply_arpack(N, pa, sig_shift, split, sig_max, info, NEV)
      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      complex(RD), intent(in)    :: sig_shift ! e-value shift
      logical, intent(in)        :: split ! determine whether to use exp or trig basis
      complex(RD), intent(out)   :: sig_max
      integer, intent(out)       :: info
      integer, intent(in), optional :: NEV

      real(RD), allocatable         :: A(:,:), A_shifted(:,:)
      integer                       :: sys_size, block_size
      class(LU_solver), allocatable :: A_factored
      type(ar_params_t)             :: ar_params

      ! allocate the system
      sys_size = @{prob_size(N)}@
      allocate( A(sys_size,sys_size) )

      ! evaluate matrices
      if (split) then
         block_size = @{block_size(N)}@

         associate( &
            A_1 => A(1:block_size, 1:block_size), &
            A_2 => A( block_size+1 : sys_size , block_size+1 : sys_size) &
         )
            @:ASSERT(SIZE(A_1,1) == block_size, 'A_1 is wrong size')
            @:ASSERT(SIZE(A_2,1) == block_size, 'A_2 is wrong size')

            call eval_matrix(N, pa, A_1, .true.)
            call eval_matrix(N, pa, A_2, .false.)

         end associate
      else
         call eval_matrix(N, pa, A)
      end if

      ! apply shift
      A_shifted = A
      call apply_shift(sig_shift%re, A_shifted)

      ! Factor the matrix
      if (split) then
         allocate( block_LU_solver :: A_factored )

         associate( &
            A_1 => A_shifted(1:block_size,1:block_size), &
            A_2 => A_shifted( block_size+1 : sys_size , block_size+1 : sys_size) &
         )
            A_factored = create_block_solver(A_1, A_2)
         end associate
      else
         allocate( generic_LU_solver :: A_factored )

         A_factored = create_generic_solver(A_shifted)
      end if

      ! set up ar params
      if (PRESENT(NEV)) then
         call ar_params%init_params(sys_size, NEV)
      else
         call ar_params%init_params(sys_size, 10)
      end if

      call eigen_shift_inv_v3(A, sys_size, CMPLX(sig_shift%re, 0._RD, KIND=RD), &
         A_factored, ar_params, sig_max, info)


   end subroutine apply_arpack

   ! subroutine apply_arpack(N, pa, sig_shift, split, sig_max, info)

   !    integer, intent(in)        :: N
   !    type(params_t), intent(in) :: pa
   !    complex(RD), intent(in)    :: sig_shift ! e-value shift
   !    logical, intent(in)        :: split ! determine whether to use exp or trig basis
   !    complex(RD), intent(out)   :: sig_max
   !    integer, intent(out)       :: info

   !    real(RD), allocatable :: A(:,:) ! the matrix that we will build into
   !    integer               :: sys_size
   !    complex(RD)           :: sig_max_1, sig_max_2
   !    logical               :: p_success, m_success ! flags for success of ARPACK

   !    if (split) then
   !       ! use the trig basis
   !       sys_size = @{block_size(N)}@

   !       allocate(A(sys_size,sys_size))

   !       ! initalize + parity
   !       call eval_matrix(N, pa, A, .true.)
   !       ! call write_matrix(A, 'p_parity.txt')
   !       ! call eigen_shift_inv(A, sig_shift, sys_size, sig_max_1, info)
   !       call factor_and_solve(A, sig_shift, sys_size, sig_max_1, info)
   !       ! print *, '+ parity result: ', sig_max_1

   !       if (info /= 0) then
   !          p_success = .false.
   !          print *, 'failed on + parity'
   !          stop
   !          ! return
   !       else
   !          p_success = .true.
   !       end if

   !       ! now do - parity

   !       call eval_matrix(N, pa, A, .false.)
   !       ! call write_matrix(A, 'm_parity.txt')
   !       ! call eigen_shift_inv(A, sig_shift, sys_size, sig_max_2, info)
   !       call factor_and_solve(A, sig_shift, sys_size, sig_max_2, info)
   !       ! print *, '- parity result: ', sig_max_2

   !       if (info /= 0) then
   !          m_success = .false.
   !          print *, 'failed on - parity'
   !          stop
   !          ! return
   !       else
   !          m_success = .true.
   !       end if

   !       ! stop

   !       ! now select the maximum result
   !       ! if (p_success .and. m_success .and. sig_max_1%re > sig_max_2%re) then
   !       !    sig_max = sig_max_1
   !       if (p_success .and. m_success) then
   !          sig_max = max_real([sig_max_1, sig_max_2])
   !       else if (p_success) then
   !          sig_max = sig_max_1
   !          info = 0
   !       else if (m_success) then
   !          sig_max = sig_max_2
   !          info = 0
   !       end if

   !    else
   !       ! exp basis
   !       sys_size = @{prob_size(N)}@

   !       allocate(A(sys_size,sys_size))

   !       call eval_matrix(N, pa, A) ! initialize matrix

   !       call eigen_shift_inv(A, sig_shift, sys_size, sig_max, info) ! run ARPACK
   !    end if

   ! end subroutine apply_arpack

   ! subroutine factor_and_solve(A, sig_shift, sys_size, sig_max, info)
   !    real(RD), intent(in)       :: A(:,:)
   !    complex(RD), intent(in)    :: sig_shift ! e-value shift
   !    integer, intent(in)        :: sys_size ! size of sytem, should be equal to
   !    complex(RD), intent(out)   :: sig_max
   !    integer, intent(out)       :: info

   !    ! LAPACK variables
   !    integer  :: IPIV(sys_size)
   !    integer  :: la_info
      
   !    ! local function variables
   !    integer :: NEV, NCV, LWORKL
   !    logical :: NCONV_err
   !    real(RD), allocatable :: A_LU(:,:) ! this way a copy of A is preserved

   !    ! This function factors the given matrix, then calls ARPACK to get the max real part

   !    A_LU = A

   !    call apply_shift(sig_shift%re, A_LU)

   !    ! perform PLU factorization
   !    call DGETRF(sys_size, sys_size, A_LU, sys_size, IPIV, la_info)
   !    if (la_info /= 0) then
   !       print *, 'Error with PLU factorisation, info = ', la_info
   !       stop
   !    end if

   !    ! set starting value for NEV
   !    NEV    = 10
   !    NCV    = (2*NEV + 1) * 1
   !    LWORKL = 3*NCV**2 + 6*NCV

   !    call eigen_shift_inv_v2(A, A_LU, sig_shift, sys_size, sig_max, info, NEV, NCV, LWORKL, IPIV, NCONV_err)

   !    ! Handle the NCONV error
   !    if (NCONV_err) then
   !       NEV    = NEV + 1
   !       NCV    = (2*NEV + 1) * 1
   !       LWORKL = 3*NCV**2 + 6*NCV

   !       call eigen_shift_inv_v2(A, A_LU, sig_shift, sys_size, sig_max, info, NEV, NCV, LWORKL, IPIV, NCONV_err)

   !       if (NCONV_err) then
   !          print *, 'failed again with NEV increasing :('
   !          stop
   !       else
   !          print *, 'Suceeded on second attempt'
   !       end if
   !    end if

   ! end subroutine factor_and_solve

   ! subroutine eigen_shift_inv(A, sig_shift, sys_size, sig_max, info)

   !    real(RD), intent(inout)    :: A(:,:)
   !    complex(RD), intent(in)    :: sig_shift ! e-value shift
   !    integer, intent(in)        :: sys_size ! size of sytem, should be equal to
   !    complex(RD), intent(out)   :: sig_max
   !    integer, intent(out)       :: info

   !    ! ARPACK parameters
   !    integer, parameter          :: NEV = 4
   !    integer, parameter          :: NCV = (2*NEV + 1) * 1
   !    integer, parameter          :: LWORKL = 3*NCV**2 + 6*NCV
   !    real(RD), parameter         :: TOL = 1E-12_RD
   !    character(len=2), parameter :: which = 'LM'
   !    character, parameter        :: bmat = 'I'

   !    integer  :: ido
   !    integer  :: iparam(11)
   !    integer  :: ipntr(14)
   !    real(RD) :: resid(sys_size)
   !    real(RD) :: v(sys_size,NCV)
   !    real(RD) :: workd(3*sys_size)
   !    real(RD) :: workl(LWORKL)
   !    real(RD) :: dr(NEV+1)
   !    real(RD) :: di(NEV+1)
   !    real(RD) :: z(sys_size,NEV+1)
   !    real(RD) :: workev(3*NCV)
   !    logical  :: select(NCV)

   !    ! matrix solving variables
   !    integer  :: IPIV(sys_size)
   !    integer  :: la_info

   !    ! variables for final output
   !    real(RD), allocatable :: A_copy(:,:) ! copy of A before any transformations are done

   !    ! Find the maximal eigenvalue using shift-invert mode

   !    ! First set up parameters

   !    iparam = 0

   !    iparam(1) = 1
   !    iparam(3) = 1000 ! max iterations
   !    iparam(7) = 3 ! 3 sets to shift inver mode

   !    ido  = 0
   !    info = 0 ! 0 means normal start, not 0 means giving an inital resid vector

   !    ! initialize these arrays
   !    dr = -HUGE(dr)
   !    di = -HUGE(di)

   !    A_copy = A ! keep a copy for later, as A will be changed by LAPACK

   !    ! factor the matrix

   !    ! apply shift
   !    call apply_shift(sig_shift%re, A)

   !    ! perform PLU factorization
   !    call DGETRF(sys_size, sys_size, A, sys_size, IPIV, la_info)
   !    if (la_info /= 0) then
   !       print *, 'Error with PLU factorisation, info = ', la_info
   !       stop
   !    end if


   !    iter_loop : do

   !       ! call to ARPACK
   !       call DNAUPD(ido, bmat, sys_size, which, NEV, TOL, resid, &
   !          NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
   !          info)

   !       if (ido == -1 .OR. ido == 1) then

   !          associate( &
   !             x => workd(ipntr(1) : ipntr(1) + sys_size - 1), &
   !             y => workd(ipntr(2) : ipntr(2) + sys_size - 1))

   !             y = x

   !             ! now solve the system (A - sig_shift*I) x = y
   !             call DGETRS('N', sys_size, 1, A, sys_size, IPIV, y, sys_size, la_info)

   !             if (la_info /= 0) then
   !                print *, 'Error with linear solve, info = ', la_info
   !                stop
   !             end if


   !          end associate

   !       else

   !          exit iter_loop

   !       end if

   !    end do iter_loop

   !    ! print *, 'Finished iteration, num itrs = ', iparam(3)
   !    ! print *, 'number of OPs = ', iparam(9)

   !    ! Check for convergence

   !    if (info /= 0) then

   !       ! print *, ' '
   !       ! print *, ' Error with _naupd, info = ', info
   !       ! print *, ' Check the documentation of _naupd'
   !       ! print *, ' '
   !       ! stop
   !       return

   !    else if (iparam(5) /= NEV) then
   !       ! note: it seems to be finding 2 eigenvalues when it should only be hitting 1
   !       print *, 'NCONV does not match NEV. NCONV = ', iparam(5)
   !       call write_matrix(A_copy, 'failed_mat.txt')
   !       ! print *, 'IDO', ido
   !       ! print *, 'sys_size', sys_size
   !       print *, 'sig_shift', sig_shift
   !       ! print *, 'info', info
   !       ! print *, 'Iparam', iparam
   !       ! stop
   !       info = 100
   !       ! return
   !    end if
   !       ! print *, 'CALLING DNEUPD'

   !    call DNEUPD(.TRUE., 'A', select, dr, di, z, SIZE(z, 1), &
   !       sig_shift%re, sig_shift%im, workev, bmat, sys_size, which, NEV, TOL, &
   !       resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
   !       LWORKL, info)
   !    ! print *, 'FINISHED CALL'

   !    if (info /= 0) then

   !       ! print *, ' '
   !       ! print *, ' Error with _neupd, info = ', info
   !       ! print *, ' Check the documentation of _neupd. '
   !       ! print *, ' '
   !       ! stop
   !       return

   !    end if

   !    ! Store the eigenvalue

   !    if (sig_shift%im /= 0) then

   !       ! need to do special calculation, according to DNEUPD


   !       eval_correction : block
   !          integer :: i
   !          logical :: conjugate_flag

   !          conjugate_flag = .false.

   !          do i = 1, NEV

   !             if (conjugate_flag) then

   !                ! last cycle we hit a complex conjugate
   !                dr(i) = dr(i-1)
   !                di(i) = -di(i-1)
   !                conjugate_flag = .false.

   !             else if (di(i) == 0) then

   !                dr(i) = triple_prod(z(:,i), A_copy)

   !             else

   !                ! we have a complex conjugate pair
   !                @:ASSERT_DEBUG(di(i) == -di(i+1), 'found e-value is not a complex conjugate')
   !                dr(i) = triple_prod(z(:,i), A_copy) + triple_prod(z(:,i+1), A_copy)
   !                di(i) = triple_prod(z(:,i), A_copy, z(:,i+1)) - triple_prod(z(:,i+1), A_copy, z(:,i))
   !                conjugate_flag = .true.

   !             end if
   !          end do
   !       end block eval_correction
   !    end if

   !    sig_max = max_real(CMPLX(dr, di, KIND=RD))

   !    ! print *,sig_max

   ! end subroutine eigen_shift_inv

   ! subroutine eigen_shift_inv_v2(A, A_LU, sig_shift, sys_size, sig_max, info, NEV, NCV, LWORKL, IPIV, NCONV_err)

   !    real(RD), intent(in)       :: A(:,:)
   !    real(RD), intent(inout)    :: A_LU(:,:)
   !    complex(RD), intent(in)    :: sig_shift ! e-value shift
   !    integer, intent(in)        :: sys_size ! size of sytem, should be equal to
   !    complex(RD), intent(out)   :: sig_max
   !    integer, intent(out)       :: info
   !    integer, intent(in)        :: NEV
   !    integer, intent(in)        :: NCV
   !    integer, intent(in)        :: LWORKL
   !    integer, intent(inout)     :: IPIV(:)
   !    logical, intent(out)       :: NCONV_err

   !    ! ARPACK parameters
   !    real(RD), parameter         :: TOL = 1E-12_RD
   !    character(len=2), parameter :: which = 'LM'
   !    character, parameter        :: bmat = 'I'

   !    integer  :: ido
   !    integer  :: iparam(11)
   !    integer  :: ipntr(14)
   !    real(RD) :: resid(sys_size)
   !    real(RD) :: v(sys_size,NCV)
   !    real(RD) :: workd(3*sys_size)
   !    real(RD) :: workl(LWORKL)
   !    real(RD) :: dr(NEV+1)
   !    real(RD) :: di(NEV+1)
   !    real(RD) :: z(sys_size,NEV+1)
   !    real(RD) :: workev(3*NCV)
   !    logical  :: select(NCV)

   !    ! matrix solving variables
   !    integer  :: la_info

   !    @:ASSERT_DEBUG(SIZE(IPIV) == sys_size)

   !    ! Find the maximal eigenvalue using shift-invert mode

   !    ! First set up parameters

   !    iparam = 0

   !    iparam(1) = 1
   !    iparam(3) = 1000 ! max iterations
   !    iparam(7) = 3 ! 3 sets to shift inver mode

   !    ido  = 0
   !    info = 0 ! 0 means normal start, not 0 means giving an inital resid vector

   !    ! initialize these arrays
   !    dr = -HUGE(dr)
   !    di = -HUGE(di)

   !    NCONV_err = .false.

   !    iter_loop : do

   !       ! call to ARPACK
   !       call DNAUPD(ido, bmat, sys_size, which, NEV, TOL, resid, &
   !          NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
   !          info)

   !       if (ido == -1 .OR. ido == 1) then

   !          associate( &
   !             x => workd(ipntr(1) : ipntr(1) + sys_size - 1), &
   !             y => workd(ipntr(2) : ipntr(2) + sys_size - 1))

   !             y = x

   !             ! now solve the system (A - sig_shift*I) x = y
   !             call DGETRS('N', sys_size, 1, A_LU, sys_size, IPIV, y, sys_size, la_info)

   !             if (la_info /= 0) then
   !                print *, 'Error with linear solve, info = ', la_info
   !                stop
   !             end if


   !          end associate

   !       else

   !          exit iter_loop

   !       end if

   !    end do iter_loop

   !    ! print *, 'Finished iteration, num itrs = ', iparam(3)
   !    ! print *, 'number of OPs = ', iparam(9)

   !    ! Check for convergence

   !    if (info /= 0) then

   !       ! print *, ' '
   !       ! print *, ' Error with _naupd, info = ', info
   !       ! print *, ' Check the documentation of _naupd'
   !       ! print *, ' '
   !       ! stop
   !       return

   !    else if (iparam(5) /= NEV) then
   !       ! note: it seems to be finding 2 eigenvalues when it should only be hitting 1
   !       print *, 'NCONV does not match NEV. NCONV = ', iparam(5)
   !       NCONV_err = .true.
   !       return
   !    end if

   !    call DNEUPD(.TRUE., 'A', select, dr, di, z, SIZE(z, 1), &
   !       sig_shift%re, sig_shift%im, workev, bmat, sys_size, which, NEV, TOL, &
   !       resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
   !       LWORKL, info)

   !    if (info /= 0) then

   !       ! print *, ' '
   !       ! print *, ' Error with _neupd, info = ', info
   !       ! print *, ' Check the documentation of _neupd. '
   !       ! print *, ' '
   !       ! stop
   !       return

   !    end if

   !    ! Store the eigenvalue

   !    if (sig_shift%im /= 0) then

   !       ! need to do special calculation, according to DNEUPD


   !       eval_correction : block
   !          integer :: i
   !          logical :: conjugate_flag

   !          conjugate_flag = .false.

   !          do i = 1, NEV

   !             if (conjugate_flag) then

   !                ! last cycle we hit a complex conjugate
   !                dr(i) = dr(i-1)
   !                di(i) = -di(i-1)
   !                conjugate_flag = .false.

   !             else if (di(i) == 0) then

   !                dr(i) = triple_prod(z(:,i), A)

   !             else

   !                ! we have a complex conjugate pair
   !                @:ASSERT_DEBUG(di(i) == -di(i+1), 'found e-val is not a complex conj')
   !                dr(i) = triple_prod(z(:,i), A) + triple_prod(z(:,i+1), A)
   !                di(i) = triple_prod(z(:,i), A, z(:,i+1)) - triple_prod(z(:,i+1), A, z(:,i))
   !                conjugate_flag = .true.

   !             end if
   !          end do
   !       end block eval_correction
   !    end if

   !    ! print *, 'Results: ', CMPLX(dr, di, KIND=RD)

   !    sig_max = max_real(CMPLX(dr, di, KIND=RD))

   ! end subroutine eigen_shift_inv_v2

   ! !****

   ! subroutine eigen_close(N, pa, sig_shift, sig_close)
      
   !    integer, intent(in)        :: N
   !    type(params_t), intent(in) :: pa
   !    complex(RD), intent(in)    :: sig_shift
   !    complex(RD), intent(out)   :: sig_close

   !    integer, parameter  :: NEV = 1
   !    integer, parameter  :: NCV = 2*NEV + 1
   !    integer, parameter  :: LWORKL = 3*NCV**2 + 6*NCV
   !    real(RD), parameter :: TOL = 1E-6_RD

   !    integer  :: ido
   !    integer  :: iparam(11)
   !    integer  :: ipntr(14)
   !    real(RD) :: resid(@{prob_size(N)}@)
   !    real(RD) :: v(@{prob_size(N)}@,NCV)
   !    real(RD) :: workd(3*@{prob_size(N)}@)
   !    real(RD) :: workl(LWORKL)
   !    integer  :: info
   !    real(RD) :: dr(NEV+1)
   !    real(RD) :: di(NEV+1)
   !    real(RD) :: z(@{prob_size(N)}@,NEV+1)
   !    real(RD) :: workev(3*NCV)
   !    logical  :: select(NCV)
   !    integer  :: ierr

   !    ! Find the maximal eigenvalue

   !    ! First set up parameters

   !    iparam = 0

   !    iparam(1) = 1
   !    iparam(3) = 300
   !    iparam(7) = 1

   !    ido = 0
   !    info = 0

   !    iter_loop : do

   !       call DNAUPD(ido, 'I', @{prob_size(N)}@, 'SR', NEV, TOL, resid, &
   !          NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
   !          info)

   !       if (ido == -1 .OR. ido == 1) then

   !          associate( &
   !             x => workd(ipntr(1):ipntr(1)+@{prob_size(N)}@-1), &
   !             y => workd(ipntr(2):ipntr(2)+@{prob_size(N)}@-1))

   !             call eval_prod(N, pa, x, y)

   !          end associate

   !       else

   !          exit iter_loop

   !       end if

   !    end do iter_loop

   !    ! Check for convergence

   !    if (info < 0) then

   !       print *, ' '
   !       print *, ' Error with _naupd, info = ', info
   !       print *, ' Check the documentation of _naupd'
   !       print *, ' '
   !       stop

   !    else

   !       call DNEUPD(.FALSE., 'A', select, dr, di, z, SIZE(z, 1), &
   !          0._RD, 0._RD, workev, 'I', @{prob_size(N)}@, 'LM', NEV, TOL, &
   !          resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
   !          LWORKL, ierr)

   !       if (ierr /= 0) then

   !          print *, ' '
   !          print *, ' Error with _neupd, info = ', ierr
   !          print *, ' Check the documentation of _neupd. '
   !          print *, ' '
   !          stop

   !       end if
         
   !    endif

   !    ! Store the eigenvalue

   !    sig_close = CMPLX(dr(1), di(1), KIND=RD)

   !    print *,sig_close

   ! end subroutine eigen_close

end program thermo
