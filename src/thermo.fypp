#:include 'forum.inc'

! preprocessor macros

! defines the prob size
#:def prob_size(N)
4*(2*${N}$+1)
#:enddef

! defines the size of parity blocks
#:def block_size(N)
2*(2*${N}$+1)
#:enddef

program thermo

   ! Uses

   use forum_m, split_ => split
   use params_m
   use matrix_m
   use finger_m

   use f95_lapack

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Variables

   character(:), allocatable :: nml_file

   integer                  :: unit
   real(RD)                 :: k_z_min
   real(RD)                 :: k_z_max
   integer                  :: n_k_z
   logical                  :: log_k_z
   logical                  :: rescale_k_z_min
   logical                  :: rescale_k_z_max
   real(RD)                 :: R0
   real(RD)                 :: Pr
   real(RD)                 :: tau
   real(RD)                 :: H_B
   real(RD)                 :: D_B
   real(RD)                 :: w_f
   integer                  :: N
   logical                  :: split
   character(256)           :: out_file
   real(RD)                 :: lam_f
   real(RD)                 :: l_f
   real(RD), allocatable    :: k_z(:)
   type(params_t)           :: pa
   integer                  :: i
   complex(RD), allocatable :: sig(:,:)
   complex(RD), allocatable :: sig_max_ar(:), sig_max_la(:)
   type(hdf5io_t)           :: hi

   ! some of my additions
   integer                  :: max_ind(1), info
   logical, allocatable     :: ar_sucess(:)

   namelist /params/ &
      k_z_min, k_z_max, n_k_z, log_k_z, rescale_k_z_min, rescale_k_z_max, &
      R0, Pr, tau, H_B, D_B, w_f, &
      N, split, &
      out_file

   ! Read arguments

   @:ASSERT(n_arg() == 1,'Syntax: thermo nml_file')

   call get_arg(1, nml_file)

   ! Read namelist parameters

   k_z_min = 1e-1
   k_z_max = 1.
   log_k_z = .FALSE.
   rescale_k_z_min = .FALSE.
   rescale_k_z_max = .FALSE.

   R0 = 1.
   Pr = 1.
   tau = 1.
   Pr = 1.
   
   H_B = 1.
   D_B = 1.
   w_f = 1.

   split = .FALSE.

   open(NEWUNIT=unit, STATUS='OLD', FILE=nml_file)
   read(unit, NML=params)
   close(unit)

   print *,'R0  :', R0
   print *,'Pr  :', Pr
   print *,'tau :', tau
   print *,'H_B :', H_B
   print *,'D_B :', D_B
   print *,'w_f :', w_f

   ! If necessary, rescale k_z range

   call solve_finger(R0, Pr, tau, lam_f, l_f)

   if (rescale_k_z_min) k_z_min = k_z_min*l_f
   if (rescale_k_z_max) k_z_max = k_z_max*l_f
      
   ! Loop over k_z

   allocate(k_z(n_k_z))

   allocate(sig(@{prob_size(N)}@, n_k_z))
   allocate(sig_max_ar(n_k_z))
   allocate(sig_max_la(n_k_z))
   allocate(ar_sucess(n_k_z))

   ar_sucess = .true.

   !!$OMP PARALLEL DO PRIVATE(pa)
   do i = 1, n_k_z

      ! Set up parameters
 
      if (log_k_z) then
         k_z(i) = 10**((LOG10(k_z_min)*(n_k_z-i) + LOG10(k_z_max)*(i-1))/(n_k_z - 1))
      else
         k_z(i) = (k_z_min*(n_k_z-i) + k_z_max*(i-1))/(n_k_z - 1)
      endif

      pa = params_t(R0, Pr, tau, H_B, D_B, w_f, k_z(i))

      ! Evaluate the full set of eigenvalues

      call eigen_all(N, pa, split, sig(:,i))

      max_ind       = MAXLOC(sig(:,i)%re)
      sig_max_la(i) = sig(max_ind(1),i)

      ! Evaluate the eigenvalue with largest real part

      if (i > 1) then

         call eigen_shift_inv(N, pa, sig_max_ar(i-1), split, sig_max_ar(i), info)

         if (info /= 0) then
            ! ARPACK failed, use the LAPACK result
            sig_max_ar(i) = sig_max_la(i)
            ar_sucess(i)  = .false.
            print *, 'ARPACK failed at index i = ', i
         end if
         ! print *, 'i = ', i, 'LAPACK result = ', sig_max_la(i), 'ARPACK result = ', sig_max_ar(i)

      else

         sig_max_ar(i) = sig_max_la(i)
         ! print *, 'i = ', i, 'LAPACK result = ', sig_max_la(i)

      end if
      ! print *, ''
      ! print *, 'i = ', i, 'ARPACK result = ', sig_max(i)


   end do

   print *,'loop complete!'
   stop

   ! Write out results

   hi = hdf5io_t(out_file, CREATE_FILE)

   call hi%write_attr('lam_f', lam_f)
   call hi%write_attr('l_f', l_f)

   call hi%write_dset('k_z', k_z)
   call hi%write_dset('sig', sig)
   call hi%write_dset('sig_max_la', sig_max_la)
   call hi%write_dset('sig_max_ar', sig_max_ar)
   call hi%write_dset('ar_sucess', ar_sucess)

   call hi%final()

   ! Finished

contains

   subroutine eigen_all(N, pa, split, sig)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      logical, intent(in)        :: split
      complex(RD), intent(out)   :: sig(:)

      real(RD), allocatable :: A(:,:)
      real(RD), allocatable :: wr(:)
      real(RD), allocatable :: wi(:)

      if (split) then

         allocate(A(@{block_size(N)}@,@{block_size(N)}@))
         allocate(wr(@{block_size(N)}@))
         allocate(wi(@{block_size(N)}@))

         call eval_matrix(N, pa, A, .TRUE.)
         call LA_GEEV(A, wr, wi)
         sig(1::2) = CMPLX(wr, wi, KIND=RD)
         
         call eval_matrix(N, pa, A, .FALSE.)
         call LA_GEEV(A, wr, wi)
         sig(2::2) = CMPLX(wr, wi, KIND=RD)

      else

         allocate(A(@{prob_size(N)}@,@{prob_size(N)}@))
         allocate(wr(@{prob_size(N)}@))
         allocate(wi(@{prob_size(N)}@))

         call eval_matrix(N, pa, A)
         call LA_GEEV(A, wr, wi)
         sig = CMPLX(wr, wi, KIND=RD)
         
      end if

   end subroutine eigen_all

   ! !****

   subroutine eigen_max(N, pa, sig_max)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      complex(RD), intent(out)   :: sig_max

      integer, parameter   :: NEV = 30
      integer, parameter   :: NCV = 2*NEV + 1
      integer, parameter   :: LWORKL = 3*NCV**2 + 6*NCV
      real(RD), parameter  :: TOL = 1E-6_RD
      character(len=2), parameter :: which = 'LR'
      character, parameter :: bmat = 'I'

      integer  :: ido
      integer  :: iparam(11)
      integer  :: ipntr(14)
      real(RD) :: resid(@{prob_size(N)}@)
      real(RD) :: v(@{prob_size(N)}@,NCV)
      real(RD) :: workd(3*@{prob_size(N)}@)
      real(RD) :: workl(LWORKL)
      integer  :: info
      real(RD) :: dr(NEV+1)
      real(RD) :: di(NEV+1)
      real(RD) :: z(@{prob_size(N)}@,NEV+1)
      real(RD) :: workev(3*NCV)
      logical  :: select(NCV)
      integer  :: ierr

      ! Find the maximal eigenvalue

      ! First set up parameters

      iparam = 0

      iparam(1) = 1
      iparam(3) = 300
      iparam(7) = 1

      ido  = 0
      info = 0

      iter_loop : do

         call DNAUPD(ido, bmat, @{prob_size(N)}@, which, NEV, TOL, resid, &
            NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
            info)

         if (ido == -1 .OR. ido == 1) then

            associate( &
               x => workd(ipntr(1):ipntr(1)+@{prob_size(N)}@-1), &
               y => workd(ipntr(2):ipntr(2)+@{prob_size(N)}@-1))

               call eval_prod_full(N, pa, x, y)

            end associate

         else

            exit iter_loop

         end if

      end do iter_loop

      ! Check for convergence

      if (info /= 0) then

         print *, ' '
         print *, ' Error with _naupd, info = ', info
         print *, ' Check the documentation of _naupd'
         print *, ' '
         stop
         ! return

      else

         call DNEUPD(.FALSE., 'A', select, dr, di, z, SIZE(z, 1), &
            0._RD, 0._RD, workev, bmat, @{prob_size(N)}@, which, NEV, TOL, &
            resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
            LWORKL, ierr)

         if (ierr /= 0) then

            print *, ' '
            print *, ' Error with _neupd, info = ', ierr
            print *, ' Check the documentation of _neupd. '
            print *, ' '
            stop
            ! return

         end if
         
      endif

      ! Store the eigenvalue

      sig_max = CMPLX(dr(NEV), di(NEV), KIND=RD)

      ! print *,sig_max

   end subroutine eigen_max

   subroutine apply_shift(sig_shift, A)
      real(RD), intent(in)    :: sig_shift
      real(RD), intent(inout) :: A(:,:)

      integer :: i

      @:ASSERT_DEBUG(SIZE(A,1) == SIZE(A,2),'non-square matrix given to shift')

      do i = 1, SIZE(A, 1)
         A(i,i) = A(i,i) - sig_shift
      end do

   end subroutine apply_shift

   pure function triple_prod(a, b, c) result(d)
      real(RD), intent(in)           :: a(:)
      real(RD), intent(in)           :: b(:,:)
      real(RD), intent(in), optional :: c(:)

      real(RD) :: d

      ! performs the triple prod a*b*c in matrix math, where a and c are vecs, b is a matrix
      ! if c is not present, sets c=a for a*b*a in matrix math

      if (PRESENT(c)) then
         d = DOT_PRODUCT(a, MATMUL(b, c))
      else
         d = DOT_PRODUCT(a, MATMUL(b, a))
      end if

   end function triple_prod

   subroutine eigen_shift_inv(N, pa, sig_shift, split, sig_max, info) !, NEV, NCV, LWORKL, info, ierr)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      complex(RD), intent(in)    :: sig_shift ! e-value shift
      logical, intent(in)        :: split ! determine whether to use exp or trig basis
      complex(RD), intent(out)   :: sig_max
      integer, intent(out)       :: info

      ! ARPACK parameters
      integer, parameter          :: NEV = 1
      integer, parameter          :: NCV = 2*NEV + 1
      integer, parameter          :: LWORKL = 3*NCV**2 + 6*NCV
      real(RD), parameter         :: TOL = 1E-6_RD
      character(len=2), parameter :: which = 'LR'
      character, parameter        :: bmat = 'I'

      integer  :: ido
      integer  :: iparam(11)
      integer  :: ipntr(14)
      real(RD) :: resid(@{prob_size(N)}@)
      real(RD) :: v(@{prob_size(N)}@,NCV)
      real(RD) :: workd(3*@{prob_size(N)}@)
      real(RD) :: workl(LWORKL)
      ! integer  :: info
      real(RD) :: dr(NEV+1)
      real(RD) :: di(NEV+1)
      real(RD) :: z(@{prob_size(N)}@,NEV+1)
      real(RD) :: workev(3*NCV)
      logical  :: select(NCV)
      ! integer  :: ierr

      ! matrix solving variables
      real(RD), allocatable :: A_u(:,:), A_l(:,:) ! upper and lower blocks. if not splitting, only A_u is used
      integer               :: IPIV(@{prob_size(N)}@)
      integer               :: la_info

      ! Find the maximal eigenvalue using shift-invert mode

      ! First set up parameters

      iparam = 0

      iparam(1) = 1
      iparam(3) = 1000
      iparam(7) = 3 ! 3 sets to shift inver mode

      ido  = 0
      info = 0

      ! initialize and factor matrix
      
      if (split) then

         ! use trig basis

         allocate( A_u(@{block_size(N)}@, @{block_size(N)}@), A_l(@{block_size(N)}@, @{block_size(N)}@) )

         call eval_matrix(N, pa, A_u, .true.)
         call eval_matrix(N, pa, A_l, .false.)

         ! apply shift
         call apply_shift(sig_shift%re, A_u)
         call apply_shift(sig_shift%re, A_l)

         ! perform PLU factorization
         ! upper block
         call DGETRF(@{block_size(N)}@,@{block_size(N)}@, A_u, @{block_size(N)}@, IPIV(1:@{block_size(N)}@), la_info)
         if (la_info /= 0) then
            print *, 'Error with PLU factorisation in first block, info = ', la_info
            stop
         end if

         ! lower block
         call DGETRF(@{block_size(N)}@,@{block_size(N)}@, A_l, @{block_size(N)}@, IPIV(@{block_size(N)}@+1 : @{prob_size(N)}@), la_info)
         if (la_info /= 0) then
            print *, 'Error with PLU factorisation in second block, info = ', la_info
            stop
         end if

      else

         ! use exponential basis

         allocate( A_u(@{prob_size(N)}@, @{prob_size(N)}@) )

         call eval_matrix(N, pa, A_u)

         ! apply shift
         call apply_shift(sig_shift%re, A_u)

         ! perform PLU factorization
         call DGETRF(@{prob_size(N)}@,@{prob_size(N)}@, A_u, @{prob_size(N)}@, IPIV, la_info)
         if (la_info /= 0) then
            print *, 'Error with PLU factorisation, info = ', la_info
            stop
         end if
         
      end if


      iter_loop : do

         call DNAUPD(ido, bmat, @{prob_size(N)}@, which, NEV, TOL, resid, &
            NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
            info)

         if (ido == -1 .OR. ido == 1) then

            associate( &
               x => workd(ipntr(1) : ipntr(1) + @{prob_size(N)}@ - 1), &
               y => workd(ipntr(2) : ipntr(2) + @{prob_size(N)}@ - 1))

               y = x

               ! now solve the system (A - sig_shift*I) x = y
               if (split) then

                  ! upper block
                  call DGETRS('N', @{block_size(N)}@, 1, A_u, @{block_size(N)}@, & 
                     IPIV(1 : @{block_size(N)}@), & 
                     y( 1 : @{block_size(N)}@), &
                     @{block_size(N)}@, la_info)

                  if (la_info /= 0) then
                     print *, 'Error with linear solve in first block, info = ', la_info
                     stop
                  end if

                  ! lower block
                  call DGETRS('N', @{block_size(N)}@, 1, A_l, @{block_size(N)}@, &
                     IPIV(@{block_size(N)}@ + 1 : @{prob_size(N)}@), & 
                     y(@{block_size(N)}@ + 1 : @{prob_size(N)}@), &
                     @{block_size(N)}@, la_info)

                  if (la_info /= 0) then
                     print *, 'Error with linear solve in second block, info = ', la_info
                     stop
                  end if

               else

                  call DGETRS('N', @{prob_size(N)}@, 1, A_u, @{prob_size(N)}@, IPIV, y, @{prob_size(N)}@, la_info)

                  if (la_info /= 0) then
                     print *, 'Error with linear solve, info = ', la_info
                     stop
                  end if

               end if

            end associate

         else

            exit iter_loop

         end if

      end do iter_loop

      ! print *, 'Finished iteration, num itrs = ', iparam(3)
      ! print *, 'number of OPs = ', iparam(9)

      ! Check for convergence

      if (info /= 0) then

         ! print *, ' '
         ! print *, ' Error with _naupd, info = ', info
         ! print *, ' Check the documentation of _naupd'
         ! print *, ' '
         ! stop
         return

      else
         ! print *, 'CALLING DNEUPD'

         call DNEUPD(.TRUE., 'A', select, dr, di, z, SIZE(z, 1), &
            sig_shift%re, sig_shift%im, workev, bmat, @{prob_size(N)}@, which, NEV, TOL, &
            resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
            LWORKL, info)
         ! print *, 'FINISHED CALL'

         if (info /= 0) then

            ! print *, ' '
            ! print *, ' Error with _neupd, info = ', info
            ! print *, ' Check the documentation of _neupd. '
            ! print *, ' '
            ! stop
            return

         end if
         
      endif

      ! Store the eigenvalue

      if (sig_shift%im == 0) then

         sig_max = CMPLX(dr(NEV), di(NEV), KIND=RD)

      else if (di(NEV) == 0) then

         ! need to do special calculation, according to DNEUPD documentation

         if (split) then

            associate( &
               z_u => z(1 : @{block_size(N)}@, :), &
               z_l => z(@{block_size(N)}@ + 1 : @{prob_size(N)}@, :) )

               sig_max%re = triple_prod(z_u(:, NEV), A_u) + triple_prod(z_l(:, NEV), A_l)

            end associate

         else

            sig_max%re = triple_prod(z(:,NEV), A_u)

         end if

         sig_max%im = 0
      
      else

         if (split) then

            associate( &
               z_u => z(1 : @{block_size(N)}@, :), &
               z_l => z(@{block_size(N)}@ + 1 : @{prob_size(N)}@, :) )

               sig_max%re = triple_prod(z_u(:,NEV), A_u) + triple_prod(z_u(:,NEV+1), A_u) &
                  + triple_prod(z_l(:,NEV), A_l) + triple_prod(z_l(:,NEV+1), A_l)

               sig_max%im = triple_prod(z_u(:,NEV), A_u, z_u(:,NEV+1)) - triple_prod(z_u(:,NEV+1), A_u, z_u(:,NEV)) &
                  + triple_prod(z_l(:,NEV), A_l, z_l(:,NEV+1)) - triple_prod(z_l(:,NEV+1), A_l, z_l(:,NEV))

            end associate

         else

            sig_max%re = triple_prod(z(:,NEV), A_u) + triple_prod(z(:,NEV+1), A_u)
            sig_max%im = triple_prod(z(:,NEV), A_u, z(:,NEV+1)) - triple_prod(z(:,NEV+1), A_u, z(:,NEV))

         end if

      end if

      ! print *,sig_max

   end subroutine eigen_shift_inv

   ! !****

   ! subroutine eigen_close(N, pa, sig_shift, sig_close)
      
   !    integer, intent(in)        :: N
   !    type(params_t), intent(in) :: pa
   !    complex(RD), intent(in)    :: sig_shift
   !    complex(RD), intent(out)   :: sig_close

   !    integer, parameter  :: NEV = 1
   !    integer, parameter  :: NCV = 2*NEV + 1
   !    integer, parameter  :: LWORKL = 3*NCV**2 + 6*NCV
   !    real(RD), parameter :: TOL = 1E-6_RD

   !    integer  :: ido
   !    integer  :: iparam(11)
   !    integer  :: ipntr(14)
   !    real(RD) :: resid(@{prob_size(N)}@)
   !    real(RD) :: v(@{prob_size(N)}@,NCV)
   !    real(RD) :: workd(3*@{prob_size(N)}@)
   !    real(RD) :: workl(LWORKL)
   !    integer  :: info
   !    real(RD) :: dr(NEV+1)
   !    real(RD) :: di(NEV+1)
   !    real(RD) :: z(@{prob_size(N)}@,NEV+1)
   !    real(RD) :: workev(3*NCV)
   !    logical  :: select(NCV)
   !    integer  :: ierr

   !    ! Find the maximal eigenvalue

   !    ! First set up parameters

   !    iparam = 0

   !    iparam(1) = 1
   !    iparam(3) = 300
   !    iparam(7) = 1

   !    ido = 0
   !    info = 0

   !    iter_loop : do

   !       call DNAUPD(ido, 'I', @{prob_size(N)}@, 'SR', NEV, TOL, resid, &
   !          NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
   !          info)

   !       if (ido == -1 .OR. ido == 1) then

   !          associate( &
   !             x => workd(ipntr(1):ipntr(1)+@{prob_size(N)}@-1), &
   !             y => workd(ipntr(2):ipntr(2)+@{prob_size(N)}@-1))

   !             call eval_prod(N, pa, x, y)

   !          end associate

   !       else

   !          exit iter_loop

   !       end if

   !    end do iter_loop

   !    ! Check for convergence

   !    if (info < 0) then

   !       print *, ' '
   !       print *, ' Error with _naupd, info = ', info
   !       print *, ' Check the documentation of _naupd'
   !       print *, ' '
   !       stop

   !    else

   !       call DNEUPD(.FALSE., 'A', select, dr, di, z, SIZE(z, 1), &
   !          0._RD, 0._RD, workev, 'I', @{prob_size(N)}@, 'LM', NEV, TOL, &
   !          resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
   !          LWORKL, ierr)

   !       if (ierr /= 0) then

   !          print *, ' '
   !          print *, ' Error with _neupd, info = ', ierr
   !          print *, ' Check the documentation of _neupd. '
   !          print *, ' '
   !          stop

   !       end if
         
   !    endif

   !    ! Store the eigenvalue

   !    sig_close = CMPLX(dr(1), di(1), KIND=RD)

   !    print *,sig_close

   ! end subroutine eigen_close

end program thermo
