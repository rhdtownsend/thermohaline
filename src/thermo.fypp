#:include 'forum.inc'

! preprocessor macros

! defines the prob size
#:def prob_size(N)
4*(2*${N}$+1)
#:enddef

! defines the size of parity blocks
#:def block_size(N)
2*(2*${N}$+1)
#:enddef

program thermo

   ! Uses

   use forum_m, split_ => split
   use params_m
   use matrix_m
   use finger_m

   use f95_lapack

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Variables

   character(:), allocatable :: nml_file

   integer                  :: unit
   real(RD)                 :: k_z_min
   real(RD)                 :: k_z_max
   integer                  :: n_k_z
   logical                  :: log_k_z
   logical                  :: rescale_k_z_min
   logical                  :: rescale_k_z_max
   real(RD)                 :: R0
   real(RD)                 :: Pr
   real(RD)                 :: tau
   real(RD)                 :: H_B
   real(RD)                 :: D_B
   real(RD)                 :: w_f
   integer                  :: N
   logical                  :: split
   character(256)           :: out_file
   real(RD)                 :: lam_f
   real(RD)                 :: l_f
   real(RD), allocatable    :: k_z(:)
   type(params_t)           :: pa
   integer                  :: i
   complex(RD), allocatable :: sig(:,:)
   complex(RD), allocatable :: sig_max_ar(:), sig_max_la(:)
   type(hdf5io_t)           :: hi

   ! some of my additions
   integer                  :: info
   logical, allocatable     :: ar_sucess(:)
   real(RD), allocatable    :: resid(:)
   integer, parameter       :: ar_start = 1

   namelist /params/ &
      k_z_min, k_z_max, n_k_z, log_k_z, rescale_k_z_min, rescale_k_z_max, &
      R0, Pr, tau, H_B, D_B, w_f, &
      N, split, &
      out_file

   ! Read arguments

   @:ASSERT(n_arg() == 1,'Syntax: thermo nml_file')

   call get_arg(1, nml_file)

   ! Read namelist parameters

   k_z_min = 1e-1
   k_z_max = 1.
   log_k_z = .FALSE.
   rescale_k_z_min = .FALSE.
   rescale_k_z_max = .FALSE.

   R0 = 1.
   Pr = 1.
   tau = 1.
   Pr = 1.
   
   H_B = 1.
   D_B = 1.
   w_f = 1.

   split = .FALSE.

   open(NEWUNIT=unit, STATUS='OLD', FILE=nml_file)
   read(unit, NML=params)
   close(unit)

   print *,'R0  :', R0
   print *,'Pr  :', Pr
   print *,'tau :', tau
   print *,'H_B :', H_B
   print *,'D_B :', D_B
   print *,'w_f :', w_f

   ! If necessary, rescale k_z range

   call solve_finger(R0, Pr, tau, lam_f, l_f)

   if (rescale_k_z_min) k_z_min = k_z_min*l_f
   if (rescale_k_z_max) k_z_max = k_z_max*l_f
      
   ! Loop over k_z

   allocate(k_z(n_k_z))

   allocate(sig(@{prob_size(N)}@, n_k_z))
   allocate(sig_max_ar(n_k_z))
   allocate(sig_max_la(n_k_z))
   allocate(ar_sucess(n_k_z))
   allocate(resid(@{prob_size(N)}@))

   ar_sucess = .true.

   !!$OMP PARALLEL DO PRIVATE(pa)
   do i = 1, n_k_z

      print *, 'i = ', i

      ! Set up parameters
 
      if (log_k_z) then
         k_z(i) = 10**((LOG10(k_z_min)*(n_k_z-i) + LOG10(k_z_max)*(i-1))/(n_k_z - 1))
      else
         k_z(i) = (k_z_min*(n_k_z-i) + k_z_max*(i-1))/(n_k_z - 1)
      endif

      pa = params_t(R0, Pr, tau, H_B, D_B, w_f, k_z(i))

      ! Evaluate the full set of eigenvalues

      call eigen_all(N, pa, split, sig(:,i))

      sig_max_la(i) = max_real(sig(:,i))

      ! Evaluate the eigenvalue with largest real part

      if (i > ar_start) then

         call apply_arpack(N, pa, sig_max_ar(i-ar_start), split, sig_max_ar(i), info) !, resid)

         if (info /= 0) then
            ! ARPACK failed, use the LAPACK result
            sig_max_ar(i) = sig_max_la(i)
            ar_sucess(i)  = .false.
            print *, 'ARPACK failed at index i = ', i
            stop
         else
            print *, achar(9), 'LAPACK result = ', sig_max_la(i)%re, sig_max_la(i)%im, &
               'ARPACK result = ', sig_max_ar(i)%re, sig_max_ar(i)%im
         end if
         ! stop 
      else

         ! call RANDOM_NUMBER(resid)
         sig_max_ar(i) = sig_max_la(i)
         ! print *, 'i = ', i, 'LAPACK result = ', sig_max_la(i)

      end if
      ! print *, ''
      ! print *, 'i = ', i, 'ARPACK result = ', sig_max(i)
      ! if (i == 1294) stop


   end do

   print *,'loop complete!'

   ! Write out results

   hi = hdf5io_t(out_file, CREATE_FILE)

   call hi%write_attr('lam_f', lam_f)
   call hi%write_attr('l_f', l_f)

   call hi%write_dset('k_z', k_z)
   call hi%write_dset('sig', sig)
   call hi%write_dset('sig_max_la', sig_max_la)
   call hi%write_dset('sig_max_ar', sig_max_ar)
   call hi%write_dset('ar_sucess', ar_sucess)

   call hi%final()

   ! Finished

contains

   subroutine eigen_all(N, pa, split, sig)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      logical, intent(in)        :: split
      complex(RD), intent(out)   :: sig(:)

      real(RD), allocatable :: A(:,:)
      real(RD), allocatable :: wr(:)
      real(RD), allocatable :: wi(:)

      if (split) then

         allocate(A(@{block_size(N)}@,@{block_size(N)}@))
         allocate(wr(@{block_size(N)}@))
         allocate(wi(@{block_size(N)}@))

         call eval_matrix(N, pa, A, .TRUE.)
         call LA_GEEV(A, wr, wi)
         sig(1::2) = CMPLX(wr, wi, KIND=RD)
         
         call eval_matrix(N, pa, A, .FALSE.)
         call LA_GEEV(A, wr, wi)
         sig(2::2) = CMPLX(wr, wi, KIND=RD)

      else

         allocate(A(@{prob_size(N)}@,@{prob_size(N)}@))
         allocate(wr(@{prob_size(N)}@))
         allocate(wi(@{prob_size(N)}@))

         call eval_matrix(N, pa, A)
         call LA_GEEV(A, wr, wi)
         sig = CMPLX(wr, wi, KIND=RD)
         
      end if

   end subroutine eigen_all

   ! !****

   subroutine eigen_max(N, pa, sig_max)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      complex(RD), intent(out)   :: sig_max

      integer, parameter   :: NEV = 30
      integer, parameter   :: NCV = 2*NEV + 1
      integer, parameter   :: LWORKL = 3*NCV**2 + 6*NCV
      real(RD), parameter  :: TOL = 1E-6_RD
      character(len=2), parameter :: which = 'LR'
      character, parameter :: bmat = 'I'

      integer  :: ido
      integer  :: iparam(11)
      integer  :: ipntr(14)
      real(RD) :: resid(@{prob_size(N)}@)
      real(RD) :: v(@{prob_size(N)}@,NCV)
      real(RD) :: workd(3*@{prob_size(N)}@)
      real(RD) :: workl(LWORKL)
      integer  :: info
      real(RD) :: dr(NEV+1)
      real(RD) :: di(NEV+1)
      real(RD) :: z(@{prob_size(N)}@,NEV+1)
      real(RD) :: workev(3*NCV)
      logical  :: select(NCV)
      integer  :: ierr

      ! Find the maximal eigenvalue

      ! First set up parameters

      iparam = 0

      iparam(1) = 1
      iparam(3) = 300
      iparam(7) = 1

      ido  = 0
      info = 0

      iter_loop : do

         call DNAUPD(ido, bmat, @{prob_size(N)}@, which, NEV, TOL, resid, &
            NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
            info)

         if (ido == -1 .OR. ido == 1) then

            associate( &
               x => workd(ipntr(1):ipntr(1)+@{prob_size(N)}@-1), &
               y => workd(ipntr(2):ipntr(2)+@{prob_size(N)}@-1))

               call eval_prod_full(N, pa, x, y)

            end associate

         else

            exit iter_loop

         end if

      end do iter_loop

      ! Check for convergence

      if (info /= 0) then

         print *, ' '
         print *, ' Error with _naupd, info = ', info
         print *, ' Check the documentation of _naupd'
         print *, ' '
         stop
         ! return

      else

         call DNEUPD(.FALSE., 'A', select, dr, di, z, SIZE(z, 1), &
            0._RD, 0._RD, workev, bmat, @{prob_size(N)}@, which, NEV, TOL, &
            resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
            LWORKL, ierr)

         if (ierr /= 0) then

            print *, ' '
            print *, ' Error with _neupd, info = ', ierr
            print *, ' Check the documentation of _neupd. '
            print *, ' '
            stop
            ! return

         end if
         
      endif

      ! Store the eigenvalue

      sig_max = CMPLX(dr(NEV), di(NEV), KIND=RD)

      ! print *,sig_max

   end subroutine eigen_max

   subroutine apply_shift(sig_shift, A)
      real(RD), intent(in)    :: sig_shift
      real(RD), intent(inout) :: A(:,:)

      integer :: i

      @:ASSERT_DEBUG(SIZE(A,1) == SIZE(A,2),'non-square matrix given to shift')

      do i = 1, SIZE(A, 1)
         A(i,i) = A(i,i) - sig_shift
      end do

   end subroutine apply_shift

   pure function triple_prod(a, b, c) result(d)
      real(RD), intent(in)           :: a(:)
      real(RD), intent(in)           :: b(:,:)
      real(RD), intent(in), optional :: c(:)

      real(RD) :: d

      ! performs the triple prod a*b*c in matrix math, where a and c are vecs, b is a matrix
      ! if c is not present, sets c=a for a*b*a in matrix math

      if (PRESENT(c)) then
         d = DOT_PRODUCT(a, MATMUL(b, c))
      else
         d = DOT_PRODUCT(a, MATMUL(b, a))
      end if

   end function triple_prod

   subroutine write_matrix(A, fname)
      ! writes matrix to file in row major order
      real(RD), intent(in) :: A(:,:)
      character(*), intent(in) :: fname
      integer :: io, i

      open(newunit=io, file=fname, status='replace', action='write')
      do i = 1, SIZE(A, 1)
         write(io, *) A(i, :)
      end do
      close(io)

   end subroutine write_matrix

   pure function max_real(sig)
      ! function gets the element with max real part for an array of complex numbers
      complex(RD), intent(in) :: sig(:)

      complex(RD) :: max_real
      integer :: max_real_loc

      max_real_loc = MAXLOC(sig%re, 1)
      max_real = sig(max_real_loc)

   end function max_real

   subroutine apply_arpack(N, pa, sig_shift, split, sig_max, info)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      complex(RD), intent(in)    :: sig_shift ! e-value shift
      logical, intent(in)        :: split ! determine whether to use exp or trig basis
      complex(RD), intent(out)   :: sig_max
      integer, intent(out)       :: info

      real(RD), allocatable :: A(:,:) ! the matrix that we will build into
      integer               :: sys_size
      complex(RD)           :: sig_max_1, sig_max_2
      logical               :: p_success, m_success ! flags for success of ARPACK

      if (split) then
         ! use the trig basis
         sys_size = @{block_size(N)}@

         allocate(A(sys_size,sys_size))

         ! initalize + parity
         call eval_matrix(N, pa, A, .true.)
         ! call write_matrix(A, 'p_parity.txt')
         call eigen_shift_inv(A, sig_shift, sys_size, sig_max_1, info)

         if (info /= 0) then
            p_success = .false.
            print *, 'failed on + parity'
            stop
            ! return
         else
            p_success = .true.
         end if

         ! now do - parity

         call eval_matrix(N, pa, A, .false.)
         ! call write_matrix(A, 'm_parity.txt')
         call eigen_shift_inv(A, sig_shift, sys_size, sig_max_2, info)

         if (info /= 0) then
            m_success = .false.
            print *, 'failed on - parity'
            stop
            ! return
         else
            m_success = .true.
         end if

         ! stop

         ! now select the maximum result
         ! if (p_success .and. m_success .and. sig_max_1%re > sig_max_2%re) then
         !    sig_max = sig_max_1
         if (p_success .and. m_success) then
            sig_max = max_real([sig_max_1, sig_max_2])
         else if (p_success) then
            sig_max = sig_max_1
            info = 0
         else if (m_success) then
            sig_max = sig_max_2
            info = 0
         end if

      else
         ! exp basis
         sys_size = @{prob_size(N)}@

         allocate(A(sys_size,sys_size))

         call eval_matrix(N, pa, A) ! initialize matrix

         call eigen_shift_inv(A, sig_shift, sys_size, sig_max, info) ! run ARPACK
      end if

   end subroutine apply_arpack

   subroutine eigen_shift_inv(A, sig_shift, sys_size, sig_max, info)

      real(RD), intent(inout)    :: A(:,:)
      complex(RD), intent(in)    :: sig_shift ! e-value shift
      integer, intent(in)        :: sys_size ! size of sytem, should be equal to
      complex(RD), intent(out)   :: sig_max
      integer, intent(out)       :: info

      ! ARPACK parameters
      integer, parameter          :: NEV = 4
      integer, parameter          :: NCV = (2*NEV + 1) * 1
      integer, parameter          :: LWORKL = 3*NCV**2 + 6*NCV
      real(RD), parameter         :: TOL = 1E-12_RD
      character(len=2), parameter :: which = 'LM'
      character, parameter        :: bmat = 'I'

      integer  :: ido
      integer  :: iparam(11)
      integer  :: ipntr(14)
      real(RD) :: resid(sys_size)
      real(RD) :: v(sys_size,NCV)
      real(RD) :: workd(3*sys_size)
      real(RD) :: workl(LWORKL)
      real(RD) :: dr(NEV+1)
      real(RD) :: di(NEV+1)
      real(RD) :: z(sys_size,NEV+1)
      real(RD) :: workev(3*NCV)
      logical  :: select(NCV)

      ! matrix solving variables
      integer  :: IPIV(sys_size)
      integer  :: la_info

      ! variables for final output
      real(RD), allocatable :: A_copy(:,:) ! copy of A before any transformations are done

      ! Find the maximal eigenvalue using shift-invert mode

      ! First set up parameters

      iparam = 0

      iparam(1) = 1
      iparam(3) = 1000 ! max iterations
      iparam(7) = 3 ! 3 sets to shift inver mode

      ido  = 0
      info = 0 ! 0 means normal start, not 0 means giving an inital resid vector

      ! initialize these arrays
      dr = -HUGE(dr)
      di = -HUGE(di)

      A_copy = A ! keep a copy for later, as A will be changed by LAPACK

      ! factor the matrix

      ! apply shift
      call apply_shift(sig_shift%re, A)

      ! perform PLU factorization
      call DGETRF(sys_size, sys_size, A, sys_size, IPIV, la_info)
      if (la_info /= 0) then
         print *, 'Error with PLU factorisation, info = ', la_info
         stop
      end if


      iter_loop : do

         ! call to ARPACK
         call DNAUPD(ido, bmat, sys_size, which, NEV, TOL, resid, &
            NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
            info)

         if (ido == -1 .OR. ido == 1) then

            associate( &
               x => workd(ipntr(1) : ipntr(1) + sys_size - 1), &
               y => workd(ipntr(2) : ipntr(2) + sys_size - 1))

               y = x

               ! now solve the system (A - sig_shift*I) x = y
               call DGETRS('N', sys_size, 1, A, sys_size, IPIV, y, sys_size, la_info)

               if (la_info /= 0) then
                  print *, 'Error with linear solve, info = ', la_info
                  stop
               end if


            end associate

         else

            exit iter_loop

         end if

      end do iter_loop

      ! print *, 'Finished iteration, num itrs = ', iparam(3)
      ! print *, 'number of OPs = ', iparam(9)

      ! Check for convergence

      if (info /= 0) then

         ! print *, ' '
         ! print *, ' Error with _naupd, info = ', info
         ! print *, ' Check the documentation of _naupd'
         ! print *, ' '
         ! stop
         return

      else if (iparam(5) /= NEV) then
         ! note: it seems to be finding 2 eigenvalues when it should only be hitting 1
         print *, 'NCONV does not match NEV. NCONV = ', iparam(5)
         call write_matrix(A_copy, 'failed_mat.txt')
         ! print *, 'IDO', ido
         ! print *, 'sys_size', sys_size
         print *, 'sig_shift', sig_shift
         ! print *, 'info', info
         ! print *, 'Iparam', iparam
         ! stop
         info = 100
         ! return
      end if
         ! print *, 'CALLING DNEUPD'

      call DNEUPD(.TRUE., 'A', select, dr, di, z, SIZE(z, 1), &
         sig_shift%re, sig_shift%im, workev, bmat, sys_size, which, NEV, TOL, &
         resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
         LWORKL, info)
      ! print *, 'FINISHED CALL'

      if (info /= 0) then

         ! print *, ' '
         ! print *, ' Error with _neupd, info = ', info
         ! print *, ' Check the documentation of _neupd. '
         ! print *, ' '
         ! stop
         return

      end if

      ! Store the eigenvalue

      if (sig_shift%im /= 0) then

         ! need to do special calculation, according to DNEUPD


         eval_correction : block
            integer :: i
            logical :: conjugate_flag

            conjugate_flag = .false.

            do i = 1, NEV

               if (conjugate_flag) then

                  ! last cycle we hit a complex conjugate
                  dr(i) = dr(i-1)
                  di(i) = -di(i-1)
                  conjugate_flag = .false.

               else if (di(i) == 0) then

                  dr(i) = triple_prod(z(:,i), A_copy)

               else

                  ! we have a complex conjugate pair
                  dr(i) = triple_prod(z(:,i), A_copy) + triple_prod(z(:,i+1), A_copy)
                  di(i) = triple_prod(z(:,i), A_copy, z(:,i+1)) - triple_prod(z(:,i+1), A_copy, z(:,i))
                  conjugate_flag = .true.

               end if
            end do
         end block eval_correction
      end if

      sig_max = max_real(CMPLX(dr, di, KIND=RD))

      ! print *,sig_max

   end subroutine eigen_shift_inv

   ! !****

   ! subroutine eigen_close(N, pa, sig_shift, sig_close)
      
   !    integer, intent(in)        :: N
   !    type(params_t), intent(in) :: pa
   !    complex(RD), intent(in)    :: sig_shift
   !    complex(RD), intent(out)   :: sig_close

   !    integer, parameter  :: NEV = 1
   !    integer, parameter  :: NCV = 2*NEV + 1
   !    integer, parameter  :: LWORKL = 3*NCV**2 + 6*NCV
   !    real(RD), parameter :: TOL = 1E-6_RD

   !    integer  :: ido
   !    integer  :: iparam(11)
   !    integer  :: ipntr(14)
   !    real(RD) :: resid(@{prob_size(N)}@)
   !    real(RD) :: v(@{prob_size(N)}@,NCV)
   !    real(RD) :: workd(3*@{prob_size(N)}@)
   !    real(RD) :: workl(LWORKL)
   !    integer  :: info
   !    real(RD) :: dr(NEV+1)
   !    real(RD) :: di(NEV+1)
   !    real(RD) :: z(@{prob_size(N)}@,NEV+1)
   !    real(RD) :: workev(3*NCV)
   !    logical  :: select(NCV)
   !    integer  :: ierr

   !    ! Find the maximal eigenvalue

   !    ! First set up parameters

   !    iparam = 0

   !    iparam(1) = 1
   !    iparam(3) = 300
   !    iparam(7) = 1

   !    ido = 0
   !    info = 0

   !    iter_loop : do

   !       call DNAUPD(ido, 'I', @{prob_size(N)}@, 'SR', NEV, TOL, resid, &
   !          NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, LWORKL, &
   !          info)

   !       if (ido == -1 .OR. ido == 1) then

   !          associate( &
   !             x => workd(ipntr(1):ipntr(1)+@{prob_size(N)}@-1), &
   !             y => workd(ipntr(2):ipntr(2)+@{prob_size(N)}@-1))

   !             call eval_prod(N, pa, x, y)

   !          end associate

   !       else

   !          exit iter_loop

   !       end if

   !    end do iter_loop

   !    ! Check for convergence

   !    if (info < 0) then

   !       print *, ' '
   !       print *, ' Error with _naupd, info = ', info
   !       print *, ' Check the documentation of _naupd'
   !       print *, ' '
   !       stop

   !    else

   !       call DNEUPD(.FALSE., 'A', select, dr, di, z, SIZE(z, 1), &
   !          0._RD, 0._RD, workev, 'I', @{prob_size(N)}@, 'LM', NEV, TOL, &
   !          resid, NCV, v, SIZE(v, 1), iparam, ipntr, workd, workl, &
   !          LWORKL, ierr)

   !       if (ierr /= 0) then

   !          print *, ' '
   !          print *, ' Error with _neupd, info = ', ierr
   !          print *, ' Check the documentation of _neupd. '
   !          print *, ' '
   !          stop

   !       end if
         
   !    endif

   !    ! Store the eigenvalue

   !    sig_close = CMPLX(dr(1), di(1), KIND=RD)

   !    print *,sig_close

   ! end subroutine eigen_close

end program thermo
