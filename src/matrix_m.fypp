#:include 'forum.inc'

module matrix_m

   ! Uses

   use forum_m
   use params_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Access specifiers

   private

   public :: eval_matrix
!   public :: eval_prod
   public :: eval_prod_full

contains

   pure function eval_k2m(pa, m) result(k2_m)
      type(params_t), intent(in) :: pa
      integer, intent(in) :: m

      real(RD) :: k2_m

      k2_m = (m * pa%l_f)**2 + pa%k_z**2

   end function eval_k2m

   subroutine eval_block_m(N, m, pa, B)

      integer, intent(in)        :: N
      integer, intent(in)        :: m
      type(params_t), intent(in) :: pa
      real(RD), intent(out)      :: B(:,:)

      real(RD) :: k2_m

      @:CHECK_BOUNDS(SIZE(B, 1),4)
      @:CHECK_BOUNDS(SIZE(B, 2),4)

      @:ASSERT_DEBUG(m >= -N .AND. M <= N,'invalid m')

      ! Evaluate the (m,m) 4x4 block of the full system matrix

      associate( &
         Pr => pa%Pr,       &
         R0 => pa%R0,       &
         tau => pa%tau,     &
         k_z => pa%k_z,     &
         H_B => pa%H_B,     &
         D_B => pa%D_B,     &
         lam_f => pa%lam_f, &
         l_f => pa%l_f,     &
         E_psi => pa%E_psi, &
         E_T => pa%E_T,     &
         E_C => pa%E_C)

         k2_m = m**2*l_f**2 + k_z**2

         B(1,1) = -Pr*k2_m
         B(1,2) =  Pr*m*l_f/k2_m
         B(1,3) = -Pr*m*l_f/k2_m
         B(1,4) = -H_B*k_z

         B(2,1) = -m*l_f
         B(2,2) = -k2_m
         B(2,3) = 0
         B(2,4) = 0

         B(3,1) = -m*l_f/R0
         B(3,2) = 0
         B(3,3) = -tau*k2_m
         B(3,4) = 0

         B(4,1) = k_z
         B(4,2) = 0
         B(4,3) = 0
         B(4,4) = -D_B*k2_m

      end associate

   end subroutine eval_block_m

   subroutine eval_block_mm1(N, m, pa, B)

      integer, intent(in)        :: N
      integer, intent(in)        :: m
      type(params_t), intent(in) :: pa
      real(RD), intent(out)      :: B(:,:)

      real(RD) :: k2_m
      real(RD) :: k2_m_m

      @:CHECK_BOUNDS(SIZE(B, 1),4)
      @:CHECK_BOUNDS(SIZE(B, 2),4)

      @:ASSERT_DEBUG(m >= -N .AND. m <= N,'invalid m')

      ! Evaluate the (m,m-1) 4x4 block of the full system matrix

      associate( &
         Pr => pa%Pr,       &
         R0 => pa%R0,       &
         tau => pa%tau,     &
         k_z => pa%k_z,     &
         H_B => pa%H_B,     &
         D_B => pa%D_B,     &
         lam_f => pa%lam_f, &
         l_f => pa%l_f,     &
         E_psi => pa%E_psi, &
         E_T => pa%E_T,     &
         E_C => pa%E_C)

         k2_m = m**2*l_f**2 + k_z**2
         k2_m_m = (m-1)**2*l_f**2 + k_z**2

         B(1,1) = l_f*k_z*E_psi/k2_m*(l_f**2 - k2_m_m)
         B(1,2) = 0
         B(1,3) = 0
         B(1,4) = 0

         B(2,1) = l_f*k_z*E_T
         B(2,2) = -l_f*k_z*E_psi
         B(2,3) = 0
         B(2,4) = 0

         B(3,1) = l_f*k_z*E_C
         B(3,2) = 0
         B(3,3) = -l_f*k_z*E_psi
         B(3,4) = 0

         B(4,1) = 0
         B(4,2) = 0
         B(4,3) = 0
         B(4,4) = -l_f*k_z*E_psi

      end associate

   end subroutine eval_block_mm1

   !****

   

   subroutine eval_block_mp1(N, m, pa, B)

      integer, intent(in)        :: N
      integer, intent(in)        :: m
      type(params_t), intent(in) :: pa
      real(RD), intent(out)      :: B(:,:)

      real(RD) :: k2_m
      real(RD) :: k2_m_p

      @:CHECK_BOUNDS(SIZE(B, 1),4)
      @:CHECK_BOUNDS(SIZE(B, 2),4)

      @:ASSERT_DEBUG(m >= -N .AND. m <= N,'invalid m')

      ! Evaluate the (m,m+1) 4x4 block of the full system matrix

      associate( &
         Pr => pa%Pr,       &
         R0 => pa%R0,       &
         tau => pa%tau,     &
         k_z => pa%k_z,     &
         H_B => pa%H_B,     &
         D_B => pa%D_B,     &
         lam_f => pa%lam_f, &
         l_f => pa%l_f,     &
         E_psi => pa%E_psi, &
         E_T => pa%E_T,     &
         E_C => pa%E_C)

         k2_m = m**2*l_f**2 + k_z**2
         k2_m_p = (m+1)**2*l_f**2 + k_z**2

         B(1,1) = -l_f*k_z*E_psi/k2_m*(l_f**2 - k2_m_p)
         B(1,2) = 0
         B(1,3) = 0
         B(1,4) = 0

         B(2,1) = l_f*k_z*E_T
         B(2,2) = l_f*k_z*E_psi
         B(2,3) = 0
         B(2,4) = 0

         B(3,1) = l_f*k_z*E_C
         B(3,2) = 0
         B(3,3) = l_f*k_z*E_psi
         B(3,4) = 0

         B(4,1) = 0
         B(4,2) = 0
         B(4,3) = 0
         B(4,4) = l_f*k_z*E_psi

      end associate

   end subroutine eval_block_mp1

   !****

   subroutine eval_matrix(N, pa, A, parity)

      integer, intent(in)           :: N
      type(params_t), intent(in)    :: pa
      real(RD), intent(out)         :: A(:,:)
      logical, intent(in), optional :: parity

      ! Evaluate the system matrix A

      if (PRESENT(parity)) then
         call eval_matrix_split(N, pa, A, parity)
      else
         call eval_matrix_full(N, pa, A)
      end if

   end subroutine eval_matrix

   !****

   subroutine eval_matrix_full(N, pa, A)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      real(RD), intent(out)      :: A(:,:)

      integer :: m
      integer :: k

      @:CHECK_BOUNDS(SIZE(A, 1),4*(2*N+1))
      @:CHECK_BOUNDS(SIZE(A, 2),4*(2*N+1))

      ! Evaluate the full system matrix A

      A = 0

      k = 1

      blockloop: do m = -N, N

         call eval_block_m(N, m, pa, A(k:k+3,k:k+3))

         if(m > -N) then
            call eval_block_mm1(N, m, pa, A(k:k+3,k-4:k-1))
         endif
            
         if(m < N) then
            call eval_block_mp1(N, m, pa, A(k:k+3,k+4:k+7))
         end if

         k = k + 4

      end do blockloop

   end subroutine eval_matrix_full

   !****

   subroutine eval_matrix_split(N, pa, A, parity)

      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      real(RD), intent(out)      :: A(:,:)
      logical, intent(in)        :: parity

      integer  :: m
      integer  :: k
      real(RD) :: B(4,4)

      @:CHECK_BOUNDS(SIZE(A, 1),2*(2*N+1))
      @:CHECK_BOUNDS(SIZE(A, 2),2*(2*N+1))

      ! Evaluate the split-parity system matrix A(+/-)

      A = 0

      k = 1

      block_loop: do m = 0, N

         call eval_block_m(N, m, pa, B) 

         if (m == 0) then
            if (parity) then
               A(k:k+1,k:k+1) = B([1,4],[1,4])
            else
               A(k:k+1,k:k+1) = B([2,3],[2,3])
            end if
         else
            A(k:k+3,k:k+3) = B
         end if

         if (m > 0) then

            call eval_block_mm1(N, m, pa, B)

            if (m == 1) then
               if (parity) then
                  A(k:k+3,k-2:k-1) = B(:,[1,4])
               else
                  A(k:k+3,k-2:k-1) = B(:,[2,3])
               end if
            else
               A(k:k+3,k-4:k-1) = B
            end if

         end if

         if (m < N) then

            call eval_block_mp1(N, m, pa, B)

            if (m == 0) then
               if (parity) then
                  A(k:k+1,k+2:k+5) = 2*B([1,4],:)
               else
                  A(k:k+1,k+2:k+5) = 2*B([2,3],:)
               end if
            else
               A(k:k+3,k+4:k+7) = B
            end if
         end if

         if (m == 0) then
            k = k + 2
         else
            k = k + 4
         end if

      end do block_loop

   end subroutine eval_matrix_split

   ! !****

   subroutine eval_prod_full(N, pa, x, y)
      integer, intent(in)        :: N
      type(params_t), intent(in) :: pa
      real(RD), intent(in)       :: x(:)
      real(RD), intent(out)      :: y(:)

      integer  :: i, m ! looping indices
      real(RD) :: k2_m, k2_m_p, k2_m_m ! the m-dependent k's

      ! coefficients
      real(RD) :: psi_1, psi_2, psi_3, psi_4
      real(RD) :: T_1, T_2, T_3, T_4
      real(RD) :: C_1, C_2, C_3, C_4
      real(RD) :: A_1, A_2, A_3

      @:CHECK_BOUNDS(SIZE(x), 4*(2*N+1))
      @:CHECK_BOUNDS(SIZE(y), 4*(2*N+1))

      constants : associate( &
         Pr    => pa%Pr,    &
         R0    => pa%R0,    &
         tau   => pa%tau,   &
         k_z   => pa%k_z,   &
         H_B   => pa%H_B,   &
         D_B   => pa%D_B,   &
         lam_f => pa%lam_f, &
         l_f   => pa%l_f,   &
         E_psi => pa%E_psi, &
         E_T   => pa%E_T,   &
         E_C   => pa%E_C )

         ! set non-m dependent coefficients
         psi_1 = l_f * k_z * E_psi
         psi_2 = -Pr
         psi_3 = Pr * l_f
         psi_4 = -H_B * k_z

         T_1 = -psi_1
         T_2 = l_f * k_z * E_T
         T_3 = -l_f
         T_4 = -1

         C_1 = T_1
         C_2 = l_f * k_z * E_C
         C_3 = -l_f / R0
         C_4 = -tau

         A_1 = T_1
         A_2 = -D_B
         A_3 = k_z

         ! do the first block (m=-N)
         m      = -N
         k2_m   = eval_k2m(pa, m)
         k2_m_p = eval_k2m(pa, m+1)

         y(1) = psi_1/k2_m*(-(l_f**2-k2_m_p)*x(5)) + psi_2*k2_m*x(1) + psi_3*m/k2_m*(x(2)-x(3)) + psi_4*x(4)
         y(2) = T_1*(-x(6)) + T_2*x(5) + T_3*m*x(1) + T_4*k2_m*x(2)
         y(3) = C_1*(-x(7)) + C_2*x(5) + C_3*m*x(1) + C_4*k2_m*x(3)
         y(4) = A_1*(-x(8)) + A_2*k2_m*x(4) + A_3*x(1)

         ! now loop through interior equations
         i = 5
         do m = -N+1, N-1

            k2_m   = eval_k2m(pa, m)
            k2_m_m = eval_k2m(pa, m-1)
            k2_m_p = eval_k2m(pa, m+1)

            loop_pointers : associate( &
               psi_m_m => x(i-4), &
               T_m_m   => x(i-3), &
               C_m_m   => x(i-2), &
               A_m_m   => x(i-1), &
               psi_m   => x(i),   &
               T_m     => x(i+1), &
               C_m     => x(i+2), &
               A_m     => x(i+3), &
               psi_m_p => x(i+4), &
               T_m_p   => x(i+5), &
               C_m_p   => x(i+6), &
               A_m_p   => x(i+7)  )

               y(i)   = psi_1/k2_m*( -(l_f**2-k2_m_p)*psi_m_p + (l_f**2-k2_m_m)*psi_m_m ) + &
                  psi_2*k2_m*psi_m + psi_3*m/k2_m*(T_m-C_m) + psi_4*A_m
               y(i+1) = T_1*(-T_m_p + T_m_m) + T_2*(psi_m_m + psi_m_p) + T_3*m*psi_m + T_4*k2_m*T_m
               y(i+2) = C_1*(-C_m_p + C_m_m) + C_2*(psi_m_m + psi_m_p) + C_3*m*psi_m + C_4*k2_m*C_m
               y(i+3) = A_1*(-A_m_p + A_m_m) + A_2*k2_m*A_m + A_3*psi_m

            end associate loop_pointers

            i = i + 4

         end do

         @:ASSERT_DEBUG(i+3 == SIZE(x),'counting error in eval_prod')

         ! now do the final 4 points
         m      = N
         k2_m   = eval_k2m(pa, m)
         k2_m_m = eval_k2m(pa, m-1)

         end_pointers : associate( &
            psi_m_m => x(i-4), &
            T_m_m   => x(i-3), &
            C_m_m   => x(i-2), &
            A_m_m   => x(i-1), &
            psi_m   => x(i),   &
            T_m     => x(i+1), &
            C_m     => x(i+2), &
            A_m     => x(i+3)  )

            y(i)   = psi_1/k2_m*( (l_f**2-k2_m_m)*psi_m_m ) + &
                     psi_2*k2_m*psi_m + psi_3*m/k2_m*(T_m-C_m) + psi_4*A_m
            y(i+1) = T_1*(T_m_m) + T_2*(psi_m_m) + T_3*m*psi_m + T_4*k2_m*T_m
            y(i+2) = C_1*(C_m_m) + C_2*(psi_m_m) + C_3*m*psi_m + C_4*k2_m*C_m
            y(i+3) = A_1*(A_m_m) + A_2*k2_m*A_m + A_3*psi_m

         end associate end_pointers

      end associate constants

   end subroutine eval_prod_full

   ! subroutine eval_prod(N, pa, x, y)

   !    integer, intent(in)        :: N
   !    type(params_t), intent(in) :: pa
   !    real(RD), intent(in)       :: x(:)
   !    real(RD), intent(out)      :: y(:)

   !    integer  :: i
   !    integer  :: m
   !    real(RD) :: B(4,4)

   !    @:CHECK_BOUNDS(SIZE(x), 4*(2*N+1))
   !    @:CHECK_BOUNDS(SIZE(y), 4*(2*N+1))

   !    ! Evaluate the system matrix operating as y <- A*x

   !    i = 1

   !    do m = -N, N

   !       call eval_D(N, m, pa, B)
   !       y(i:i+3) = MATMUL(B, x(i:i+3))

   !       if(m > -N) then
   !          call eval_L(N, m, pa, B)
   !          y(i:i+3) = y(i:i+3) +  MATMUL(B, x(i-4:i-1))
   !       end if

   !       if(m < N) then
   !          call eval_U(N, m, pa, B)
   !          y(i:i+3) = y(i:i+3) + MATMUL(B, x(i+4:i+7))
   !       end if

   !       i = i + 4

   !    end do

   ! end subroutine eval_prod

end module matrix_m
